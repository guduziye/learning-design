简单工厂模式（simple factory）：又叫静态工厂方法，由一个工厂对象决定创建某一种产品对象类的实例。主要用来创建同一类对象。

工厂方法模式（factory method）：通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。

抽象工厂模式（abstract factory）：通过对类的工厂抽象使其业务用于对产品类簇的创建，而不负责创建某一类产品的实例。

创造者模式（builder）：将一个复杂对象的构建层与其表示层相互分离，同样的构建过程可采用不同的表示。

原型模式（prototype）：用原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法。

单例模式（singleton）：只允许实例化一次的对象类。

外观模式（facade）：为一组复杂的子系统接口提供一个更高级的统一接口，通过这个接口使得对子系统的访问更容易。

适配器模式（adapter）：将一个类（对象）的接口（方法或者属性）转化成另一个接口，以满足用户需求，使类（对象）之间的不兼容问题通过适配器得以解决。

代理模式（proxy）：由于一个对象不能直接引用另一个对象，所以需要通过代理对象在这两个对象之间起到中介的作用。

装饰者模式（decorator）：在不改变原对象的基础上，通过对其进行包装拓展（添加属性或方法）使原有对象可以满足用户的更复杂需求。

桥接模式（bridge）：在系统沿着多个维度变化的同时，又不增加其复杂度并达到解耦。

组合模式（composite）：将对象组合成树形结构以表示"部分整体"的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。

享元模式（flyweight）：运用共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销。

模板方法模式（template method）：父类中定义一组操作算法骨架，而将一些实现步骤延迟到子类中，使得子类可以不改变父类的算法结构的同时可重新定义算法中某些实现步骤。

观察者模式（observer）：发布订阅者模式或消息机制，定义了一种依赖关系，解决了主体对象与观察者之间功能的耦合。

状态模式（state）：当一个对象的内部状态发生改变时，会导致其行为的改变，这看起来像是改变了对象。

策略模式（strategy）：将定义的一组算法封装起来，使其相互之间可以替换。封装的算法具有一定的独立性，不会随客户端变化而变化。

职责链模式（chain of responsibility）：解决请求的发送者与请求的接受者之间的耦合，通过职责链上的多个对象对分解请求流程，实现请求在多个对象之间的传递，直到最后一个对象完成请求的处理。

命令模式（command）：将请求与现实解耦并封装成独立对象，从而使不同的请求对客户端的实现参数化。

访问者模式（visitor）：针对于对象结构中的元素，定义在不改变该对象的前提下访问结构中元素的新方法。

中介者模式（mediator）：通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合。有时中介者对象也可以改变对象之间的交互。

备忘录模式：在不破坏对象的封装性的前提下，在对象之外捕获并保存该对象内部的状态以便日后对象使用或是对象恢复到以前的某个状态。

迭代器模式：在不暴露对象内部结构的同时，可以顺序的访问聚合对象的内部元素。

解释器模式：对于一种语言，给出其文法表示形式，并定义一种解释器，通过使用这中解释器来解释语言中定义的句子。

链模式：通过在对象方法中将当前对象返回，实现对同一个对象多个方法的链式调用。从而简化对该对象的多个方法的多次调用时，对该对象的多次引用。

委托模式：多个对象接收并处理统一请求，他们将请求委托给另一个对象统一处理请求。

数据访问对象模式（Data access object,DAO）：抽象和封装对数据源的访问与存储，DAO通过对数据源链接的管理方便对数据的访问与存储。

节流模式（throttler）：对重复的业务逻辑进行节流控制，执行最后一次操作并取消其他操作，以提高性能。

等待者模式（waiter）：通过多个异步进程监听，来触发未发生的动作。

模块化：将复杂的系统分解成高内聚、低耦合的模块，使系统开发变得可控、可维护、可扩展，提高模块的复用率。

同步模块化（SMD synchronous module definition）：请求发出后，无论模块是否存在，立即执行后续的逻辑，实现模块开发中对模块的立即引用。